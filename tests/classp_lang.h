/* BEGIN HEADER */
#ifndef classp_lang_INCLUDE_
#define classp_lang_INCLUDE_

#include <assert.h>
#include <unordered_map>
#include <utility>

#include "classp.h"

// Include files generated by bison
#include "classp_lang.yacc.hh"
#include "location.hh"
#include "position.hh"

namespace classp_lang {
using std::istream;
using std::ostream;
using classp::classpPrint;
using classp::classpFormat;
using classp::AttributeMap;

// Location and state information from the parser.
typedef location ParseState;

class AstNode;
/* BEGIN FORWARD DECLARATIONS */
class Alternation;
class AttributeDeclaration;
class CasePattern;
class ClassDefinition;
class Declarations;
class Expression;
class Iterator;
class Iterator0OrMore;
class Iterator1OrMore;
class Pattern;
class PatternSequence;
class SampleDeclaration;
class SyntaxDeclaration;
/* END FORWARD DECLARATIONS */

// Base class for classp_lang AST nodes
class AstNode : public classp::ClasspNode {
 public:
  string className() override { return "AstNode"; }
  AstNode(ParseState parseState)
    : parseState(parseState) {
    }

  // Write out a bracketed form of this AST from the declared syntax.
  virtual void bracketFormat(std::ostream& out, AstNode* self) {
    assert(false);
  }

  ParseState parseState;
};

/* BEGIN CLASS DEFINITIONS */
class Declarations: public AstNode {
 public:
  string className() override { return "Declarations"; }
  Declarations(ParseState parseState, vector<ClassDefinition*> decl);
  static Declarations* parse(istream& input, ostream& errors);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  vector<ClassDefinition*> decl;
};

class ClassDefinition: public AstNode {
 public:
  string className() override { return "ClassDefinition"; }
  ClassDefinition(ParseState parseState, identifier class_name, AttributeMap& keyword_args);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  identifier class_name;
  identifier parent_name;
  vector<AttributeDeclaration*> attributes;
  vector<SyntaxDeclaration*> syntax_decl;
  vector<SampleDeclaration*> sample_decl;
  bool parseable;
  bool has_parent_name = false;
};

class AttributeDeclaration: public AstNode {
 public:
  string className() override { return "AttributeDeclaration"; }
  AttributeDeclaration(ParseState parseState, identifier attribute_name, identifier type_name, AttributeMap& keyword_args);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  bool is_optional;
  identifier attribute_name;
  identifier type_name;
  Expression* default_value = nullptr;
  bool is_array;
  SyntaxDeclaration* syntax_decl = nullptr;
  bool has_default_value = false;
  bool has_syntax_decl = false;
};

class SyntaxDeclaration: public AstNode {
 public:
  string className() override { return "SyntaxDeclaration"; }
  SyntaxDeclaration(ParseState parseState, Pattern* pattern, AttributeMap& keyword_args);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  Pattern* pattern = nullptr;
  Associativity assoc;
  int precedence;
  bool has_assoc = false;
  bool has_precedence = false;
};

class Pattern: public AstNode {
 public:
  string className() override { return "Pattern"; }
  Pattern(ParseState parseState);
  void printMembers(ostream& out) override;
  void bracketFormat(ostream& out, AstNode* self) override;

};

class Alternation: public Pattern {
 public:
  string className() override { return "Alternation"; }
  Alternation(ParseState parseState, vector<Pattern*> alternates);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  vector<Pattern*> alternates;
};

class Iterator: public Pattern {
 public:
  string className() override { return "Iterator"; }
  Iterator(ParseState parseState, Pattern* pattern1, Pattern* pattern2);
  void printMembers(ostream& out) override;

  Pattern* pattern1 = nullptr;
  Pattern* pattern2 = nullptr;
};

class Iterator0OrMore: public Iterator {
 public:
  string className() override { return "Iterator0OrMore"; }
  Iterator0OrMore(ParseState parseState, Pattern* pattern1, Pattern* pattern2);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

};

class Iterator1OrMore: public Iterator {
 public:
  string className() override { return "Iterator1OrMore"; }
  Iterator1OrMore(ParseState parseState, Pattern* pattern1, Pattern* pattern2);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

};

class PatternSequence: public Pattern {
 public:
  string className() override { return "PatternSequence"; }
  PatternSequence(ParseState parseState, vector<Pattern*> list);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  vector<Pattern*> list;
};

class CasePattern: public Pattern {
 public:
  string className() override { return "CasePattern"; }
  CasePattern(ParseState parseState, identifier attribute, AttributeMap& keyword_args);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  identifier attribute;
  vector<Pattern*> patterns;
  vector<Expression*> exprs;
};

class Expression: public AstNode {
 public:
  string className() override { return "Expression"; }
  Expression(ParseState parseState, identifier id);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  identifier id;
};

class SampleDeclaration: public AstNode {
 public:
  string className() override { return "SampleDeclaration"; }
  SampleDeclaration(ParseState parseState, string sample_decl, AttributeMap& keyword_args);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  string sample_decl;
  string expected;
  SampleCheck check;
  bool has_expected = false;
};
/* END CLASS DEFINITIONS */

}  // namespace classp_lang
#endif // classp_lang_INCLUDE_

/* END HEADER */
